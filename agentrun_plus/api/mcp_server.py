"""MCP Server for AgentRun - Exposes sessions as MCP tools

This module creates an MCP (Model Context Protocol) server that exposes
AgentRun's session management and code execution capabilities as tools.
The MCP server shares state with the REST API through the same backend
and sessions dictionary.

Quick Start Example for LLM Agents:

    # 1. Create a session
    session = create_session()
    # Returns: {"session_id": "abc123", "workdir": "abc123",
    #           "source_path": "/path/to/abc123/src",
    #           "artifact_path": "/path/to/abc123/artifacts"}

    # 2. Upload data file (must be base64 encoded)
    import base64
    with open("data.csv", "rb") as f:
        content = base64.b64encode(f.read()).decode()
    upload_file(session['session_id'], "data.csv", content)

    # 3. Execute code to process data
    # IMPORTANT: Access uploaded files via 'src/' prefix
    code = '''
import pandas as pd
df = pd.read_csv('src/data.csv')  # Note: 'src/' prefix required
result = df.describe()

# Save output to artifacts/ for downloading
result.to_csv('artifacts/summary.csv')  # Note: 'artifacts/' prefix
print(result)
'''
    result = execute_code(session['session_id'], code,
                         ignore_unsafe_functions=['open'])
    print(result['output'])  # See the printed result

    # 4. Download the generated file
    download = download_file(session['session_id'], "artifacts/summary.csv")
    # Returns base64-encoded content

    # 5. Create a visualization
    plot_code = '''
import matplotlib.pyplot as plt
import pandas as pd

df = pd.read_csv('src/data.csv')
df.plot(kind='bar')
plt.savefig('artifacts/plot.png')  # Save directly to artifacts/
print("Plot saved!")
'''
    execute_code(session['session_id'], plot_code,
                ignore_unsafe_functions=['open'])

    # 6. Download the plot
    plot = download_file(session['session_id'], "artifacts/plot.png")

    # 7. Clean up
    close_session(session['session_id'])

Directory Structure:
    workdir/                    # Code execution happens here (working directory)
    ├── src/                    # Uploaded files go here
    │   ├── data.csv           # Access as 'src/data.csv' from code
    │   └── script.py          # Access as 'src/script.py' from code
    └── artifacts/             # Save output files here
        ├── summary.csv        # Save as 'artifacts/summary.csv' from code
        └── plot.png           # Save as 'artifacts/plot.png' from code
"""

from typing import Dict, Optional, List
from fastmcp import FastMCP
from backend import AgentRun, AgentRunSession
import base64
import tempfile
import os
from pathlib import Path
from uuid import uuid4
import logging
import sys

# Create logger
log = logging.getLogger(__name__)
log.setLevel(logging.INFO)
# Only add handler if none exists (prevents duplicates on module reload)
if not log.handlers:
    stream_handler = logging.StreamHandler(sys.stdout)
    log.addHandler(stream_handler)


def create_mcp_app(backend: AgentRun, sessions: Dict[str, AgentRunSession]):
    """Create MCP app that shares state with REST API

    Args:
        backend: Shared AgentRun backend instance
        sessions: Shared sessions dictionary (same as REST API)

    Returns:
        ASGI application for mounting to FastAPI
    """

    # Create FastMCP instance
    # In FastMCP 2.x, only the name parameter is required
    mcp = FastMCP("AgentRun")

    # Tool 1: Create Session
    @mcp.tool()
    def create_session() -> dict:
        """Create a new AgentRun session for code execution

        Returns a session_id that should be used for all subsequent operations
        in this session. Sessions are isolated with their own working directories.

        Directory Structure:
            workdir/                    # Code execution happens here
            ├── src/                    # Upload files here (source_path)
            │   └── your_file.py        # Accessible as 'src/your_file.py' from code
            └── artifacts/              # Download files from here (artifact_path)
                └── output.png          # Generated by your code

        Important: Code executes in workdir. To access uploaded files, use:
            - Relative path: 'src/filename.txt'
            - Or: import os; os.chdir('src')

        Returns:
            dict: {
                "session_id": str,       # Unique session identifier
                "workdir": str,          # Working directory name
                "source_path": str,      # Full path to src/ (for uploads)
                "artifact_path": str     # Full path to artifacts/ (for downloads)
            }
        """
        try:
            # Generate unique session ID
            session_id = uuid4().hex
            workdir = session_id

            log.info(f'[MCP] Creating session {session_id}...')

            # Create session using backend
            session = backend.create_session(workdir=workdir)

            # Store session reference (shared with REST API)
            sessions[session_id] = session

            return {
                "session_id": session_id,
                "workdir": workdir,
                "source_path": session.source_path(),
                "artifact_path": session.artifact_path()
            }
        except Exception as e:
            log.error(f'[MCP] Failed to create session: {e}')
            return {
                "success": False,
                "error": f"Failed to create session: {str(e)}"
            }

    # Tool 2: Execute Code
    @mcp.tool()
    def execute_code(
        session_id: str,
        code: str,
        ignore_dependencies: Optional[List[str]] = None,
        ignore_unsafe_functions: Optional[List[str]] = None
    ) -> dict:
        """Execute Python code in a session's isolated environment

        The code is executed in the session's working directory (workdir) with safety
        checks and dependency management. Python errors will be captured
        and returned in the output field.

        File Access:
            - Current directory: workdir (parent of src/ and artifacts/)
            - Uploaded files: Access via 'src/filename.txt'
            - Save artifacts: Save to 'artifacts/output.png' or use shutil.copy to artifacts/
            - Example: open('src/data.csv', 'r')  # Read uploaded file

        Safety:
            - Unsafe functions (open, exec, eval, etc.) are blocked by default
            - Use ignore_unsafe_functions=['open'] to allow specific functions
            - Dependencies are auto-installed if not in ignore_dependencies list

        Args:
            session_id: The session ID returned from create_session
            code: Python code to execute
            ignore_dependencies: List of dependencies to ignore during validation
            ignore_unsafe_functions: List of unsafe functions to allow (e.g., ['open'])

        Returns:
            dict: {
                "success": bool,  # True if code executed without errors
                "output": str     # Code output or error message
            }
        """
        # Validate session exists
        if session_id not in sessions:
            return {
                "success": False,
                "output": "",
                "error": f"Session {session_id} not found"
            }

        try:
            session = sessions[session_id]

            # Execute code using session
            success, output = session.execute_code(
                python_code=code,
                ignore_dependencies=ignore_dependencies,
                ignore_unsafe_functions=ignore_unsafe_functions
            )

            log.info(f'[MCP] Code executed in session {session_id}: success={success}')

            return {
                "success": success,
                "output": output
            }
        except Exception as e:
            log.error(f'[MCP] Error executing code in session {session_id}: {e}')
            return {
                "success": False,
                "output": str(e),
                "error": str(e)
            }

    # Tool 3: Upload File
    @mcp.tool()
    def upload_file(
        session_id: str,
        filename: str,
        content_base64: str
    ) -> dict:
        """Upload a file to a session's source directory

        Files are uploaded to the session's src/ subdirectory. When executing code,
        access uploaded files using the relative path 'src/filename'.

        Example workflow:
            1. upload_file(session_id, "data.csv", base64_content)
            2. execute_code(session_id, "import pandas as pd; df = pd.read_csv('src/data.csv')")

        The file content must be base64 encoded for safe JSON transmission.

        Args:
            session_id: The session ID
            filename: Name of the file (no path separators allowed)
            content_base64: Base64-encoded file content

        Returns:
            dict: {
                "success": bool,
                "destination": str,  # Full path where file was saved
                "message": str
            }
        """
        # Validate session exists
        if session_id not in sessions:
            return {
                "success": False,
                "error": f"Session {session_id} not found"
            }

        # Security check: Validate filename (no path traversal)
        if ".." in filename or "/" in filename or "\\" in filename:
            return {
                "success": False,
                "error": "Invalid filename: path separators and traversal attempts are not allowed"
            }

        # Additional validation: ensure filename is safe
        if not filename or filename.startswith('.'):
            return {
                "success": False,
                "error": "Invalid filename: cannot be empty or start with a dot"
            }

        try:
            session = sessions[session_id]

            # Decode base64 content
            try:
                content = base64.b64decode(content_base64)
            except Exception as e:
                return {
                    "success": False,
                    "error": f"Failed to decode base64 content: {str(e)}"
                }

            # Create temporary file to hold the content
            with tempfile.NamedTemporaryFile(delete=False) as tmp_file:
                try:
                    # Write decoded content to temp file
                    tmp_file.write(content)
                    tmp_file.flush()

                    # Copy file to session using backend API
                    destination = session.copy_file_to(
                        local_path=tmp_file.name,
                        dest_file_name=filename
                    )

                    # Verify destination is within source path
                    source_path = Path(session.source_path()).resolve()
                    dest_path = Path(destination).resolve()

                    try:
                        dest_path.relative_to(source_path)
                    except ValueError:
                        return {
                            "success": False,
                            "error": "Internal error: file was not placed in the correct directory"
                        }

                    log.info(f'[MCP] Uploaded file {filename} to session {session_id}')

                    return {
                        "success": True,
                        "destination": destination,
                        "message": f"File '{filename}' uploaded successfully"
                    }
                finally:
                    # Clean up temporary file
                    os.unlink(tmp_file.name)

        except Exception as e:
            log.error(f'[MCP] Failed to upload file to session {session_id}: {e}')
            return {
                "success": False,
                "error": f"Failed to upload file: {str(e)}"
            }

    # Tool 4: Download File
    @mcp.tool()
    def download_file(
        session_id: str,
        src_path: str
    ) -> dict:
        """Download a file from a session's artifact directory

        Files can only be downloaded from the session's artifacts/ subdirectory.
        Your code should save output files directly to the artifacts/ directory.

        Example - Save a plot:
            import matplotlib.pyplot as plt
            plt.plot([1, 2, 3])
            plt.savefig('artifacts/plot.png')  # Save directly to artifacts/

        Then download it:
            download_file(session_id, "artifacts/plot.png")  # Must include artifacts/ prefix!

        Example - Save CSV output:
            import pandas as pd
            df.to_csv('artifacts/results.csv')  # Save directly to artifacts/

        The file content is returned base64-encoded for safe JSON transmission.

        Args:
            session_id: The session ID
            src_path: Path to file, either:
                     - Relative to workdir: "artifacts/plot.png"
                     - Absolute path: "/full/path/to/session/artifacts/plot.png"
                     NOTE: Must include "artifacts/" prefix for relative paths!

        Returns:
            dict: {
                "success": bool,
                "filename": str,           # Name of the file
                "content_base64": str,     # Base64-encoded file content
                "size_bytes": int          # Size of original file
            }
        """
        # Validate session exists
        if session_id not in sessions:
            return {
                "success": False,
                "error": f"Session {session_id} not found"
            }

        session = sessions[session_id]

        # Security check: Ensure requested path is within artifact directory
        artifact_path = Path(session.artifact_path()).resolve()
        requested_path = Path(src_path)

        # Check for path traversal attempts
        if ".." in src_path:
            return {
                "success": False,
                "error": f"Path traversal attempts are not allowed: {src_path}"
            }

        # Validate path is within artifact directory
        try:
            if requested_path.is_absolute():
                requested_path.relative_to(artifact_path)
        except ValueError:
            return {
                "success": False,
                "error": f"Access denied: path must be within session's artifact directory"
            }

        try:
            # Create temporary directory for download
            with tempfile.TemporaryDirectory() as tmp_dir:
                # Copy file from session to temp directory
                session.copy_file_from(
                    src_path=src_path,
                    local_dest_path=tmp_dir
                )

                # Get the filename
                src_filename = os.path.basename(src_path)
                downloaded_file_path = os.path.join(tmp_dir, src_filename)

                # Check if file exists
                if not os.path.exists(downloaded_file_path):
                    return {
                        "success": False,
                        "error": "File was not found after copy operation"
                    }

                # Read file and encode as base64
                with open(downloaded_file_path, 'rb') as f:
                    file_content = f.read()

                content_base64 = base64.b64encode(file_content).decode('utf-8')

                log.info(f'[MCP] Downloaded file {src_filename} from session {session_id}')

                return {
                    "success": True,
                    "filename": src_filename,
                    "content_base64": content_base64,
                    "size_bytes": len(file_content)
                }

        except Exception as e:
            log.error(f'[MCP] Failed to download file from session {session_id}: {e}')
            return {
                "success": False,
                "error": f"Failed to download file: {str(e)}"
            }

    # Tool 5: List Sessions
    @mcp.tool()
    def list_sessions() -> dict:
        """List all active session IDs

        Returns a list of all currently active sessions (created via REST API
        or MCP). Sessions are shared between both protocols.

        Returns:
            dict: {
                "active_sessions": List[str],  # List of session IDs
                "count": int                    # Number of active sessions
            }
        """
        session_ids = list(sessions.keys())
        log.info(f'[MCP] Listed {len(session_ids)} active sessions')

        return {
            "active_sessions": session_ids,
            "count": len(session_ids)
        }

    # Tool 6: Get Session Info
    @mcp.tool()
    def get_session_info(session_id: str) -> dict:
        """Get information about a session

        Returns the session's working directory paths (source and artifact).

        Args:
            session_id: The session ID

        Returns:
            dict: {
                "session_id": str,
                "source_path": str,
                "artifact_path": str
            }
        """
        # Validate session exists
        if session_id not in sessions:
            return {
                "success": False,
                "error": f"Session {session_id} not found"
            }

        session = sessions[session_id]

        return {
            "session_id": session_id,
            "source_path": session.source_path(),
            "artifact_path": session.artifact_path()
        }

    # Tool 7: Close Session
    @mcp.tool()
    def close_session(session_id: str) -> dict:
        """Close a session and clean up resources

        Closes the session and removes all associated files. The session_id
        will no longer be valid after this operation.

        Args:
            session_id: The session ID to close

        Returns:
            dict: {
                "success": bool,
                "message": str
            }
        """
        # Validate session exists
        if session_id not in sessions:
            return {
                "success": False,
                "error": f"Session {session_id} not found"
            }

        try:
            session = sessions[session_id]
            backend.close_session(session)
            del sessions[session_id]

            log.info(f'[MCP] Closed session {session_id}')

            return {
                "success": True,
                "message": f"Session {session_id} closed successfully"
            }
        except Exception as e:
            log.error(f'[MCP] Failed to close session {session_id}: {e}')
            return {
                "success": False,
                "error": f"Failed to close session: {str(e)}"
            }

    # Tool 8: Get Packages
    @mcp.tool()
    def get_packages() -> dict:
        """Get the list of Python packages installed in the runner container

        Returns all Python packages available in the execution environment.
        This is useful for LLMs to know which libraries are pre-installed
        so they can generate code that uses available packages without
        triggering unnecessary installations.

        This tool does not require a session_id since packages are shared
        across all sessions in the same runner container.

        Returns:
            dict: {
                "packages": List[str],   # List of installed package names
                "count": int             # Number of installed packages
            }
        """
        try:
            packages = backend.get_installed_packages()
            log.info(f'[MCP] Listed {len(packages)} installed packages')
            return {
                "packages": packages,
                "count": len(packages)
            }
        except Exception as e:
            log.error(f'[MCP] Failed to get packages: {e}')
            return {
                "success": False,
                "error": f"Failed to get packages: {str(e)}"
            }

    # Tool 9: Health Check
    @mcp.tool()
    def get_health() -> dict:
        """Check AgentRun server health status

        Returns the health status and count of active sessions.
        Useful for verifying the server is running before making requests.
        Provides parity with the REST API /health endpoint.

        Returns:
            dict: {
                "status": str,           # "healthy" or "unhealthy"
                "active_sessions": int   # Number of active sessions
            }
        """
        try:
            return {
                "status": "healthy",
                "active_sessions": len(sessions)
            }
        except Exception as e:
            log.error(f'[MCP] Health check failed: {e}')
            return {
                "status": "unhealthy",
                "error": str(e)
            }

    # Return the ASGI app for mounting
    # In FastMCP 2.x, use http_app() to get the ASGI application
    return mcp.http_app(path='/')
